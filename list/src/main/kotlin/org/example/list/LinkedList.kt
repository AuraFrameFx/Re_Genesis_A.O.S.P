/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example.list

class LinkedList : List<String> {
    private var head: Node? = null

    /**
     * Appends the given string to the end of the list.
     *
     * If the list is empty the element becomes the new head; otherwise it is linked as the current tail's next node.
     *
     * @param element The string to append.
     */
    fun add(element: String) {
        val newNode = Node(element)

        val it = tail(head)
        if (it == null) {
            head = newNode
        } else {
            it.next = newNode
        }
    }

    /**
     * Returns the last node (tail) of the singly linked list starting from [head], or `null` if the list is empty.
     *
     * @param head the starting node of the list, or `null` for an empty list
     * @return the tail node or `null` when [head] is `null`
     */
    private fun tail(head: Node?): Node? {
        var it: Node?

        it = head
        while (it?.next != null) {
            it = it.next
        }

        return it
    }

    /**
     * Removes the first occurrence of the given element from the list.
     *
     * Searches from the head and unlinks the first node whose data equals the provided
     * element (case-sensitive). Only the first match is removed.
     *
     * @param element The string value to remove (case-sensitive).
     * @return True if a node was removed; false if no matching element was found.
     */
    fun remove(element: String): Boolean {
        var result = false
        var previousIt: Node? = null
        var it: Node? = head
        while (!result && it != null) {
            if (0 == element.compareTo(it.data)) {
                result = true
                unlink(previousIt, it)
                break
            }
            previousIt = it
            it = it.next
        }

        return result
    }

    /**
     * Remove `currentIt` from the list by relinking its predecessor or updating `head`.
     *
     * If `currentIt` is the current head, `head` is set to `currentIt.next`; otherwise
     * `previousIt.next` is updated to skip `currentIt`.
     *
     * @param previousIt The node immediately before `currentIt`, or null when `currentIt` is the head.
     * @param currentIt The node to unlink from the list.
     */
    private fun unlink(previousIt: Node?, currentIt: Node) {
        if (currentIt == head) {
            head = currentIt.next
        } else {
            previousIt?.next = currentIt.next
        }
    }

    /**
     * Returns the number of elements in the list.
     *
     * Traverses the linked list from the head and counts nodes.
     *
     * @return The current size (number of nodes) in this list.
     */
    fun calculateSize(): Int {
        var size = 0

        var it = head
        while (it != null) {
            ++size
            it = it.next
        }

        return size
    }

    /**
     * Returns the element at the given 0-based index in the list.
     *
     * If `idx` is negative it is treated as 0 (the head element). Throws
     * IndexOutOfBoundsException when the index is out of range or the list is empty.
     *
     * @param idx 0-based position of the element to retrieve.
     * @return the string stored at the specified index.
     * @throws IndexOutOfBoundsException if no element exists at the requested index.
     */
    private fun getNodeAt(idx: Int): Node? {
        if (idx < 0) return null
        var index = idx
        var it = head
        while (index > 0 && it != null) {
            it = it.next
            index--
        }
        return it
    }

    private data class Node(val data: String) {
        var next: Node? = null
    }

    override val size: Int
        get() = calculateSize()

    override fun contains(element: String): Boolean {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun containsAll(elements: Collection<String>): Boolean {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun get(index: Int): String {
        val node = getNodeAt(index) ?: throw IndexOutOfBoundsException("Index: $index")
        return node.data
    }

    override fun indexOf(element: String): Int {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun isEmpty(): Boolean {
        return head == null
    }

    override fun iterator(): Iterator<String> {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun lastIndexOf(element: String): Int {
        throw UnsupportedOperationException("Not yet implemented")
    }

    override fun listIterator(): ListIterator<String> = listIterator(0)

    override fun listIterator(index: Int): ListIterator<String> {
        if (index < 0 || index > size) {
            throw IndexOutOfBoundsException("Index: $index, Size: $size")
        }

        return object : ListIterator<String> {
            private var current = head
            private var currentIndex = 0

            init {
                repeat(index) {
                    current = current?.next
                    currentIndex++
                }
            }

            override fun hasNext(): Boolean = currentIndex < size
            override fun hasPrevious(): Boolean = currentIndex > 0
            override fun nextIndex(): Int = currentIndex
            override fun previousIndex(): Int = currentIndex - 1

            override fun next(): String {
                if (!hasNext()) throw NoSuchElementException()
                val value = current?.data ?: throw NoSuchElementException()
                current = current?.next
                currentIndex++
                return value
            }

            override fun previous(): String {
                if (!hasPrevious()) throw NoSuchElementException()
                currentIndex--
                current = head
                repeat(currentIndex) { current = current?.next }
                return current?.data ?: throw NoSuchElementException()
            }

            override fun add(element: String) = throw UnsupportedOperationException()
            override fun remove() = throw UnsupportedOperationException()
            override fun set(element: String) = throw UnsupportedOperationException()
        }
    }

    override fun subList(fromIndex: Int, toIndex: Int): List<String> {
        if (fromIndex < 0 || toIndex > size || fromIndex > toIndex) {
            throw IndexOutOfBoundsException("fromIndex: $fromIndex, toIndex: $toIndex, size: $size")
        }

        val result = mutableListOf<String>()
        var current = head

        repeat(fromIndex) { current = current?.next }
        repeat(toIndex - fromIndex) {
            current?.let {
                result.add(it.data)
                current = it.next
            }
        }
        return result
    }
}
